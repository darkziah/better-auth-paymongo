{
  "version": 3,
  "sources": ["../src/server.ts", "../src/cache.ts", "../node_modules/nanostores/clean-stores/index.js", "../node_modules/nanostores/atom/index.js", "../src/client.ts", "../src/react.ts"],
  "sourcesContent": [
    "import type { BetterAuthPlugin } from \"better-auth\";\nimport type { PaymongoAutumnConfig, AttachResponse, CheckResponse, UsageRecord } from \"./types\";\nimport { createAuthEndpoint, sessionMiddleware } from \"better-auth/api\";\nimport { cache } from \"./cache\";\n\nexport const paymongo = <\n    TPlans extends Record<string, any>,\n    TFeatures extends Record<string, any>\n>(\n    config: PaymongoAutumnConfig<TPlans, TFeatures>\n) => {\n    const paymongoFetch = async (path: string, options: RequestInit) => {\n        const auth = Buffer.from(config.secretKey + ':').toString('base64');\n        return fetch(`https://api.paymongo.com/v1${path}`, {\n            ...options,\n            headers: {\n                'Authorization': `Basic ${auth}`,\n                'Content-Type': 'application/json',\n                ...options.headers,\n            },\n        });\n    };\n\n    return {\n        id: \"paymongo\",\n        schema: {\n            paymongoUsage: {\n                fields: {\n                    entityType: {\n                        type: \"string\",\n                        required: true,\n                    },\n                    entityId: {\n                        type: \"string\",\n                        required: true,\n                    },\n                    featureId: {\n                        type: \"string\",\n                        required: true,\n                    },\n                    balance: {\n                        type: \"number\",\n                        required: true,\n                    },\n                    limit: {\n                        type: \"number\",\n                        required: true,\n                    },\n                    periodStart: {\n                        type: \"date\",\n                        required: true,\n                    },\n                    periodEnd: {\n                        type: \"date\",\n                        required: true,\n                    },\n                    planId: {\n                        type: \"string\",\n                        required: true,\n                    },\n                    checkoutSessionId: {\n                        type: \"string\",\n                        required: false,\n                    },\n                    createdAt: {\n                        type: \"date\",\n                        required: true,\n                    },\n                    updatedAt: {\n                        type: \"date\",\n                        required: true,\n                    },\n                },\n            },\n        },\n        endpoints: {\n            attach: createAuthEndpoint(\n                '/paymongo/attach',\n                {\n                    method: 'POST',\n                    use: [sessionMiddleware]\n                },\n                async (ctx) => {\n                    const user = ctx.context.session.user;\n                    const body = ctx.body as {\n                        planId: string;\n                        successUrl: string;\n                        cancelUrl: string;\n                        organizationId?: string;\n                    };\n\n                    const { planId, successUrl, cancelUrl, organizationId } = body;\n\n                    const plan = config.plans[planId];\n                    if (!plan) {\n                        throw new Error(`Plan ${planId} not found`);\n                    }\n\n                    const entityType = organizationId ? 'organization' : 'user';\n                    const entityId = organizationId || user.id;\n\n                    const checkoutResponse = await paymongoFetch('/checkout_sessions', {\n                        method: 'POST',\n                        body: JSON.stringify({\n                            data: {\n                                attributes: {\n                                    line_items: [\n                                        {\n                                            name: plan.displayName,\n                                            amount: plan.amount,\n                                            currency: plan.currency,\n                                            quantity: 1\n                                        }\n                                    ],\n                                    payment_method_types: ['card', 'gcash', 'grab_pay'],\n                                    success_url: successUrl,\n                                    cancel_url: cancelUrl,\n                                    billing: {\n                                        email: user.email\n                                    }\n                                }\n                            }\n                        })\n                    });\n\n                    if (!checkoutResponse.ok) {\n                        const error = await checkoutResponse.text();\n                        throw new Error(`PayMongo API error: ${error}`);\n                    }\n\n                    const checkoutData = await checkoutResponse.json();\n                    const sessionId = checkoutData.data.id;\n                    const checkoutUrl = checkoutData.data.attributes.checkout_url;\n\n                    const now = new Date();\n                    const periodEnd = new Date(now);\n                    periodEnd.setMonth(periodEnd.getMonth() + (plan.interval === 'yearly' ? 12 : 1));\n\n                    const planFeatures = plan.features;\n                    \n                    for (const [featureId, featureValue] of Object.entries(planFeatures)) {\n                        const featureConfig = config.features[featureId];\n                        \n                        if (featureConfig && featureConfig.type === 'metered') {\n                            const limit = typeof featureValue === 'number' ? featureValue : featureConfig.limit;\n                            \n                            await ctx.context.adapter.create({\n                                model: 'paymongoUsage',\n                                data: {\n                                    entityType,\n                                    entityId,\n                                    featureId,\n                                    balance: limit,\n                                    limit,\n                                    periodStart: now,\n                                    periodEnd,\n                                    planId,\n                                    checkoutSessionId: sessionId,\n                                    createdAt: now,\n                                    updatedAt: now\n                                }\n                            });\n                        }\n                    }\n\n                    return ctx.json<AttachResponse>({\n                        checkoutUrl,\n                        sessionId\n                    });\n                }\n            ),\n            check: createAuthEndpoint(\n                '/paymongo/check',\n                {\n                    method: 'GET',\n                    use: [sessionMiddleware]\n                },\n                async (ctx) => {\n                    const user = ctx.context.session.user;\n                    const query = ctx.query as {\n                        feature: string;\n                        organizationId?: string;\n                    };\n\n                    const { feature: featureId, organizationId } = query;\n\n                    if (!featureId) {\n                        throw new Error('Missing required query param: feature');\n                    }\n\n                    const entityType = organizationId ? 'organization' : 'user';\n                    const entityId = organizationId || user.id;\n\n                    const usageRecord = await ctx.context.adapter.findOne({\n                        model: 'paymongoUsage',\n                        where: [\n                            { field: 'entityType', value: entityType },\n                            { field: 'entityId', value: entityId },\n                            { field: 'featureId', value: featureId }\n                        ]\n                    }) as UsageRecord | null;\n\n                    if (!usageRecord) {\n                        return ctx.json<CheckResponse>({\n                            allowed: false\n                        });\n                    }\n\n                    const cacheKey = `paymongo:${entityType}:${entityId}:session`;\n                    let sessionStatus = cache.get<string>(cacheKey);\n\n                    if (!sessionStatus && usageRecord.checkoutSessionId) {\n                        const response = await paymongoFetch(`/checkout_sessions/${usageRecord.checkoutSessionId}`, { \n                            method: 'GET' \n                        });\n                        \n                        if (response.ok) {\n                            const data = await response.json();\n                            sessionStatus = data.data.attributes.payment_intent?.attributes?.status || 'pending';\n                            cache.set(cacheKey, sessionStatus, 60);\n                        }\n                    }\n\n                    if (sessionStatus && sessionStatus !== 'succeeded') {\n                        return ctx.json<CheckResponse>({\n                            allowed: false,\n                            planId: usageRecord.planId\n                        });\n                    }\n\n                    const featureConfig = config.features[featureId];\n                    const now = new Date();\n\n                    if (usageRecord.periodEnd < now) {\n                        const newPeriodEnd = new Date(now);\n                        newPeriodEnd.setMonth(newPeriodEnd.getMonth() + 1);\n                        \n                        await ctx.context.adapter.update({\n                            model: 'paymongoUsage',\n                            where: [{ field: 'id', value: usageRecord.id }],\n                            update: {\n                                balance: usageRecord.limit,\n                                periodStart: now,\n                                periodEnd: newPeriodEnd,\n                                updatedAt: now\n                            }\n                        });\n\n                        usageRecord.balance = usageRecord.limit;\n                        usageRecord.periodStart = now;\n                        usageRecord.periodEnd = newPeriodEnd;\n                    }\n\n                    if (featureConfig && featureConfig.type === 'metered') {\n                        return ctx.json<CheckResponse>({\n                            allowed: usageRecord.balance > 0,\n                            balance: usageRecord.balance,\n                            limit: usageRecord.limit,\n                            planId: usageRecord.planId\n                        });\n                    } else {\n                        return ctx.json<CheckResponse>({\n                            allowed: true,\n                            planId: usageRecord.planId\n                        });\n                    }\n                }\n            ),\n            track: createAuthEndpoint(\n                '/paymongo/track',\n                {\n                    method: 'POST',\n                    use: [sessionMiddleware]\n                },\n                async (ctx) => {\n                    const user = ctx.context.session.user;\n                    const { feature, delta = 1, organizationId } = ctx.body as {\n                        feature: string;\n                        delta?: number;\n                        organizationId?: string;\n                    };\n\n                    const entityType = organizationId ? 'organization' : 'user';\n                    const entityId = organizationId || user.id;\n\n                    const usageRecord = await ctx.context.adapter.findOne({\n                        model: 'paymongoUsage',\n                        where: [\n                            { field: 'entityType', value: entityType },\n                            { field: 'entityId', value: entityId },\n                            { field: 'featureId', value: feature }\n                        ]\n                    }) as UsageRecord | null;\n\n                    if (!usageRecord) {\n                        throw new Error(`No usage record found for feature: ${feature}`);\n                    }\n\n                    const newBalance = Math.max(0, usageRecord.balance - delta);\n\n                    await ctx.context.adapter.update({\n                        model: 'paymongoUsage',\n                        where: [{ field: 'id', value: usageRecord.id }],\n                        update: { balance: newBalance, updatedAt: new Date() }\n                    });\n\n                    return ctx.json({ success: true, balance: newBalance, limit: usageRecord.limit });\n                }\n            )\n        }\n    } satisfies BetterAuthPlugin;\n};",
    "interface CacheEntry<T> {\n  value: T;\n  expiresAt: number;\n}\n\nconst store = new Map<string, CacheEntry<unknown>>();\n\nexport const cache = {\n  get<T>(key: string): T | null {\n    const entry = store.get(key);\n    if (!entry) return null;\n    if (Date.now() > entry.expiresAt) {\n      store.delete(key);\n      return null;\n    }\n    return entry.value as T;\n  },\n\n  set<T>(key: string, value: T, ttlSeconds = 60): void {\n    store.set(key, {\n      value,\n      expiresAt: Date.now() + ttlSeconds * 1000,\n    });\n  },\n\n  delete(key: string): void {\n    store.delete(key);\n  },\n};\n",
    "import { cleanTasks } from '../task/index.js'\n\nexport let clean = Symbol('clean')\n\nexport let cleanStores = (...stores) => {\n  if (process.env.NODE_ENV === 'production') {\n    throw new Error(\n      'cleanStores() can be used only during development or tests'\n    )\n  }\n  cleanTasks()\n  for (let $store of stores) {\n    if ($store) {\n      if ($store.mocked) delete $store.mocked\n      if ($store[clean]) $store[clean]()\n    }\n  }\n}\n",
    "import { clean } from '../clean-stores/index.js'\n\nlet listenerQueue = []\nlet lqIndex = 0\nconst QUEUE_ITEMS_PER_LISTENER = 4\nexport let epoch = 0\n\n/* @__NO_SIDE_EFFECTS__ */\nexport const atom = initialValue => {\n  let listeners = []\n  let $atom = {\n    get() {\n      if (!$atom.lc) {\n        $atom.listen(() => {})()\n      }\n      return $atom.value\n    },\n    lc: 0,\n    listen(listener) {\n      $atom.lc = listeners.push(listener)\n\n      return () => {\n        for (\n          let i = lqIndex + QUEUE_ITEMS_PER_LISTENER;\n          i < listenerQueue.length;\n\n        ) {\n          if (listenerQueue[i] === listener) {\n            listenerQueue.splice(i, QUEUE_ITEMS_PER_LISTENER)\n          } else {\n            i += QUEUE_ITEMS_PER_LISTENER\n          }\n        }\n\n        let index = listeners.indexOf(listener)\n        if (~index) {\n          listeners.splice(index, 1)\n          if (!--$atom.lc) $atom.off()\n        }\n      }\n    },\n    notify(oldValue, changedKey) {\n      epoch++\n      let runListenerQueue = !listenerQueue.length\n      for (let listener of listeners) {\n        listenerQueue.push(listener, $atom.value, oldValue, changedKey)\n      }\n\n      if (runListenerQueue) {\n        for (\n          lqIndex = 0;\n          lqIndex < listenerQueue.length;\n          lqIndex += QUEUE_ITEMS_PER_LISTENER\n        ) {\n          listenerQueue[lqIndex](\n            listenerQueue[lqIndex + 1],\n            listenerQueue[lqIndex + 2],\n            listenerQueue[lqIndex + 3]\n          )\n        }\n        listenerQueue.length = 0\n      }\n    },\n    /* It will be called on last listener unsubscribing.\n       We will redefine it in onMount and onStop. */\n    off() {},\n    set(newValue) {\n      let oldValue = $atom.value\n      if (oldValue !== newValue) {\n        $atom.value = newValue\n        $atom.notify(oldValue)\n      }\n    },\n    subscribe(listener) {\n      let unbind = $atom.listen(listener)\n      listener($atom.value)\n      return unbind\n    },\n    value: initialValue\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    $atom[clean] = () => {\n      listeners = []\n      $atom.lc = 0\n      $atom.off()\n    }\n  }\n\n  return $atom\n}\n\nexport const readonlyType = store => store\n",
    "import type { BetterAuthClientPlugin } from \"better-auth/client\";\nimport type { BetterFetchOption, BetterFetch } from \"@better-fetch/fetch\";\nimport { atom } from \"nanostores\";\nimport { useAuthQuery } from \"better-auth/client\";\nimport type { paymongo } from \"./server\";\nimport type { SubscriptionData, BasePlanConfig, BaseAddonConfig } from \"./types\";\n\n// Config type for plans and addons\nexport interface PaymongoConfig {\n    plans: Record<string, BasePlanConfig>;\n    addons: Record<string, BaseAddonConfig>;\n}\n\nexport const paymongoClient = () => {\n    // Signal atoms for triggering refetches - created OUTSIDE getAtoms but inside the factory\n    // This ensures they persist across the lifetime of the client\n    const $configSignal = atom<boolean>(false);\n    const $subscriptionSignal = atom<boolean>(false);\n\n    return {\n        id: \"paymongo\",\n        $InferServerPlugin: {} as ReturnType<typeof paymongo>,\n\n        getAtoms: ($fetch: BetterFetch) => {\n            // Create reactive query atoms using better-auth's useAuthQuery\n            // These will automatically become useConfig() and useSubscription() hooks\n            const config = useAuthQuery<PaymongoConfig>(\n                $configSignal,\n                \"/paymongo/config\",\n                $fetch,\n                { method: \"GET\" }\n            );\n\n            const subscription = useAuthQuery<SubscriptionData | null>(\n                $subscriptionSignal,\n                \"/paymongo/get-subscription\",\n                $fetch,\n                { method: \"GET\" }\n            );\n\n            return {\n                // Signal atoms (prefixed with $) - used for triggering refetches\n                $configSignal,\n                $subscriptionSignal,\n                // Query atoms - these become useConfig() and useSubscription() hooks automatically\n                config,\n                subscription\n            };\n        },\n\n        getActions: ($fetch: <T>(url: string, options?: BetterFetchOption) => Promise<{ data: T | null; error: { message: string } | null }>) => ({\n            /**\n             * Create a PaymentIntent for subscribing to a plan\n             */\n            createPaymentIntent: async (options: { planId: string; organizationId?: string }, fetchOptions?: BetterFetchOption) => {\n                return $fetch<{ clientKey: string; paymentIntentId: string }>(`/paymongo/create-payment-intent`, {\n                    method: \"POST\",\n                    body: options,\n                    ...fetchOptions\n                });\n            },\n\n            /**\n             * Create a subscription (handles trial or paid subscriptions)\n             */\n            createSubscription: async (options: { planId: string; paymentIntentId?: string; organizationId?: string }, fetchOptions?: BetterFetchOption) => {\n                return $fetch<SubscriptionData>(`/paymongo/create-subscription`, {\n                    method: \"POST\",\n                    body: options,\n                    ...fetchOptions\n                });\n            },\n\n            /**\n             * Verify and sync subscription status\n             */\n            verifySubscription: async (options?: { organizationId?: string }, fetchOptions?: BetterFetchOption) => {\n                const query = options?.organizationId ? `?organizationId=${options.organizationId}` : \"\";\n                return $fetch<SubscriptionData | null>(`/paymongo/verify-subscription${query}`, {\n                    method: \"GET\",\n                    ...fetchOptions\n                });\n            },\n\n            /**\n             * Cancel subscription (sets cancelAtPeriodEnd flag)\n             */\n            cancelSubscription: async (options?: { organizationId?: string }, fetchOptions?: BetterFetchOption) => {\n                return $fetch<SubscriptionData>(`/paymongo/cancel-subscription`, {\n                    method: \"POST\",\n                    body: options ?? {},\n                    ...fetchOptions\n                });\n            },\n\n            /**\n             * Get the current plan ID for the active organization or user\n             */\n            getPlan: async (options?: { organizationId?: string }, fetchOptions?: BetterFetchOption) => {\n                const query = options?.organizationId ? `?organizationId=${options.organizationId}` : \"\";\n                const res = await $fetch<SubscriptionData | null>(`/paymongo/get-subscription${query}`, {\n                    method: \"GET\",\n                    ...fetchOptions\n                });\n                return {\n                    data: res.data?.planId ?? null,\n                    error: res.error\n                };\n            },\n\n            /**\n             * Get the full subscription data for the active organization or user\n             */\n            getSubscription: async (options?: { organizationId?: string }, fetchOptions?: BetterFetchOption) => {\n                const query = options?.organizationId ? `?organizationId=${options.organizationId}` : \"\";\n                return $fetch<SubscriptionData | null>(`/paymongo/get-subscription${query}`, {\n                    method: \"GET\",\n                    ...fetchOptions\n                });\n            },\n\n            /**\n             * Check if the organization or user has an active subscription\n             */\n            hasActiveSubscription: async (options?: { organizationId?: string }, fetchOptions?: BetterFetchOption) => {\n                const query = options?.organizationId ? `?organizationId=${options.organizationId}` : \"\";\n                const res = await $fetch<SubscriptionData | null>(`/paymongo/get-subscription${query}`, {\n                    method: \"GET\",\n                    ...fetchOptions\n                });\n                const isActive = res.data?.status === \"active\" || res.data?.status === \"trialing\";\n                return {\n                    data: isActive,\n                    error: res.error\n                };\n            },\n\n            /**\n             * Convert a trial subscription to a paid subscription\n             */\n            convertTrial: async (options: { paymentIntentId: string; organizationId?: string }, fetchOptions?: BetterFetchOption) => {\n                return $fetch<SubscriptionData>(`/paymongo/convert-trial`, {\n                    method: \"POST\",\n                    body: options,\n                    ...fetchOptions\n                });\n            },\n\n            /**\n             * Update payment method for an active subscription\n             */\n            updatePayment: async (options: { paymentIntentId: string; organizationId?: string }, fetchOptions?: BetterFetchOption) => {\n                return $fetch<SubscriptionData>(`/paymongo/update-payment`, {\n                    method: \"POST\",\n                    body: options,\n                    ...fetchOptions\n                });\n            },\n\n            /**\n             * Switch to a different plan (handles proration for upgrades, scheduling for downgrades)\n             */\n            switchPlan: async (options: { newPlanId: string; paymentIntentId?: string; organizationId?: string }, fetchOptions?: BetterFetchOption) => {\n                return $fetch<SubscriptionData | { requiresPayment: boolean; prorationAmount: number; currency: string }>(`/paymongo/switch-plan`, {\n                    method: \"POST\",\n                    body: options,\n                    ...fetchOptions\n                });\n            },\n\n            /**\n             * Add an addon to the subscription\n             */\n            addAddon: async (options: { addonId: string; quantity?: number; organizationId?: string }, fetchOptions?: BetterFetchOption) => {\n                return $fetch<SubscriptionData>(`/paymongo/add-addon`, {\n                    method: \"POST\",\n                    body: { quantity: 1, ...options },\n                    ...fetchOptions\n                });\n            },\n\n            /**\n             * Check usage for a specific limit key\n             */\n            checkUsage: async (options: { limitKey: string; organizationId?: string }, fetchOptions?: BetterFetchOption) => {\n                const params = new URLSearchParams({ limitKey: options.limitKey });\n                if (options.organizationId) params.set('organizationId', options.organizationId);\n                return $fetch<{ usage: number; limit: number; remaining: number; allowed: boolean }>(`/paymongo/check-usage?${params}`, {\n                    method: \"GET\",\n                    ...fetchOptions\n                });\n            },\n\n            /**\n             * Increment (or decrement with negative) usage for a limit key\n             */\n            incrementUsage: async (options: { limitKey: string; quantity?: number; organizationId?: string }, fetchOptions?: BetterFetchOption) => {\n                return $fetch<{ success: boolean; usage: number; limit: number }>(`/paymongo/increment-usage`, {\n                    method: \"POST\",\n                    body: { quantity: 1, ...options },\n                    ...fetchOptions\n                });\n            }\n        }),\n\n        // Path methods tell better-auth which HTTP method to use for each path\n        pathMethods: {\n            \"/paymongo/config\": \"GET\",\n            \"/paymongo/get-subscription\": \"GET\",\n            \"/paymongo/verify-subscription\": \"GET\",\n            \"/paymongo/check-usage\": \"GET\"\n        },\n\n        // Atom listeners trigger signal updates when matching API calls are made\n        atomListeners: [\n            {\n                matcher(path: string) {\n                    return path === \"/paymongo/config\";\n                },\n                signal: \"$configSignal\"\n            },\n            {\n                matcher(path: string) {\n                    return path.startsWith(\"/paymongo/\") &&\n                        (path.includes(\"subscription\") ||\n                            path.includes(\"switch-plan\") ||\n                            path.includes(\"convert-trial\") ||\n                            path.includes(\"cancel\") ||\n                            path.includes(\"add-addon\"));\n                },\n                signal: \"$subscriptionSignal\"\n            }\n        ]\n    } satisfies BetterAuthClientPlugin;\n};\n",
    "/**\n * React utilities for better-auth-paymongo\n * \n * When using better-auth's React client (createAuthClient from \"better-auth/react\"),\n * hooks are automatically generated from the plugin's getAtoms():\n * \n * - client.useConfig() - Returns the config (plans and addons)\n * - client.useSubscription() - Returns the current subscription\n * \n * This module exports helper functions to compute limits and extract\n * useful data from the hook results.\n */\n\nimport type { SubscriptionData, BasePlanConfig, BaseAddonConfig } from \"./types\";\nimport type { PaymongoConfig } from \"./client\";\n\n// Re-export types for convenience\nexport type { PaymongoConfig } from \"./client\";\nexport type { SubscriptionData, BasePlanConfig, BaseAddonConfig } from \"./types\";\n\n// =============================================================================\n// Type for useConfig/useSubscription hook results (from better-auth)\n// =============================================================================\n\nexport interface AuthQueryResult<T> {\n  data: T | null;\n  error: { message: string } | null;\n  isPending: boolean;\n  isRefetching: boolean;\n  refetch: (queryParams?: { query?: Record<string, string> }) => Promise<void>;\n}\n\n// =============================================================================\n// Helper Functions\n// =============================================================================\n\n/**\n * Compute limits by merging base plan limits with add-on bonuses\n */\nexport function computeLimits(\n  subscription: SubscriptionData | null,\n  plans: Record<string, BasePlanConfig>,\n  addons?: Record<string, BaseAddonConfig>\n): Record<string, number> {\n  if (!subscription) return {};\n\n  const plan = plans[subscription.planId];\n  if (!plan) return {};\n\n  const limits = { ...plan.limits };\n\n  if (addons && subscription.addons) {\n    for (const [addonId, qty] of Object.entries(subscription.addons)) {\n      const addon = addons[addonId];\n      if (addon?.limitBonuses) {\n        for (const [key, bonus] of Object.entries(addon.limitBonuses)) {\n          limits[key] = (limits[key] || 0) + bonus * qty;\n        }\n      }\n    }\n  }\n\n  return limits;\n}\n\n/**\n * Extract the current plan from config and subscription data\n */\nexport function getCurrentPlan(\n  config: PaymongoConfig | null,\n  subscription: SubscriptionData | null\n): BasePlanConfig | null {\n  if (!config || !subscription) return null;\n  return config.plans[subscription.planId] ?? null;\n}\n\n/**\n * Check if a subscription is active (active or trialing)\n */\nexport function isSubscriptionActive(subscription: SubscriptionData | null): boolean {\n  return subscription?.status === \"active\" || subscription?.status === \"trialing\";\n}\n\n/**\n * Get trial status information\n */\nexport function getTrialStatus(subscription: SubscriptionData | null): {\n  isTrialing: boolean;\n  trialEndsAt: Date | null;\n  daysRemaining: number;\n  hasUsedTrial: boolean;\n} {\n  const isTrialing = subscription?.status === \"trialing\";\n  let trialEndsAt: Date | null = null;\n  let daysRemaining = 0;\n\n  if (subscription?.trialEndsAt) {\n    trialEndsAt = new Date(subscription.trialEndsAt);\n    const now = new Date();\n    const msRemaining = trialEndsAt.getTime() - now.getTime();\n    daysRemaining = Math.max(0, Math.ceil(msRemaining / (1000 * 60 * 60 * 24)));\n  }\n\n  return {\n    isTrialing,\n    trialEndsAt,\n    daysRemaining,\n    hasUsedTrial: !!subscription?.trialUsedAt\n  };\n}\n\n/**\n * Get usage information for a specific limit\n */\nexport function getUsageInfo(\n  limitKey: string,\n  subscription: SubscriptionData | null,\n  config: PaymongoConfig | null,\n  includeAddons: boolean = true\n): {\n  usage: number;\n  limit: number;\n  remaining: number;\n  isOverLimit: boolean;\n} {\n  const usage = subscription?.usage?.[limitKey] ?? 0;\n  let limit = 0;\n\n  if (subscription?.planId && config?.plans[subscription.planId]) {\n    const computedLimits = includeAddons\n      ? computeLimits(subscription, config.plans, config.addons)\n      : (config.plans[subscription.planId]?.limits ?? {});\n    limit = computedLimits[limitKey] ?? 0;\n  }\n\n  const remaining = Math.max(0, limit - usage);\n  const isOverLimit = usage >= limit && limit > 0;\n\n  return { usage, limit, remaining, isOverLimit };\n}\n\n/**\n * Format price amount for display\n * @param amount Amount in smallest currency unit (e.g., centavos)\n * @param currency Currency code (e.g., \"PHP\")\n */\nexport function formatPrice(amount: number, currency: string): string {\n  const majorUnits = amount / 100;\n  return new Intl.NumberFormat(undefined, {\n    style: \"currency\",\n    currency: currency\n  }).format(majorUnits);\n}\n"
  ],
  "mappings": "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",
  "debugId": "7F9FCAD8A4199A6864756E2164756E21",
  "names": []
}