{
  "version": 3,
  "sources": ["../node_modules/nanostores/clean-stores/index.js", "../node_modules/nanostores/atom/index.js", "../node_modules/nanostores/listen-keys/index.js", "../src/client.ts", "../node_modules/@nanostores/react/index.js", "../src/react.ts", "../src/server.ts"],
  "sourcesContent": [
    "import { cleanTasks } from '../task/index.js'\n\nexport let clean = Symbol('clean')\n\nexport let cleanStores = (...stores) => {\n  if (process.env.NODE_ENV === 'production') {\n    throw new Error(\n      'cleanStores() can be used only during development or tests'\n    )\n  }\n  cleanTasks()\n  for (let $store of stores) {\n    if ($store) {\n      if ($store.mocked) delete $store.mocked\n      if ($store[clean]) $store[clean]()\n    }\n  }\n}\n",
    "import { clean } from '../clean-stores/index.js'\n\nlet listenerQueue = []\nlet lqIndex = 0\nconst QUEUE_ITEMS_PER_LISTENER = 4\nexport let epoch = 0\n\n/* @__NO_SIDE_EFFECTS__ */\nexport const atom = initialValue => {\n  let listeners = []\n  let $atom = {\n    get() {\n      if (!$atom.lc) {\n        $atom.listen(() => {})()\n      }\n      return $atom.value\n    },\n    lc: 0,\n    listen(listener) {\n      $atom.lc = listeners.push(listener)\n\n      return () => {\n        for (\n          let i = lqIndex + QUEUE_ITEMS_PER_LISTENER;\n          i < listenerQueue.length;\n\n        ) {\n          if (listenerQueue[i] === listener) {\n            listenerQueue.splice(i, QUEUE_ITEMS_PER_LISTENER)\n          } else {\n            i += QUEUE_ITEMS_PER_LISTENER\n          }\n        }\n\n        let index = listeners.indexOf(listener)\n        if (~index) {\n          listeners.splice(index, 1)\n          if (!--$atom.lc) $atom.off()\n        }\n      }\n    },\n    notify(oldValue, changedKey) {\n      epoch++\n      let runListenerQueue = !listenerQueue.length\n      for (let listener of listeners) {\n        listenerQueue.push(listener, $atom.value, oldValue, changedKey)\n      }\n\n      if (runListenerQueue) {\n        for (\n          lqIndex = 0;\n          lqIndex < listenerQueue.length;\n          lqIndex += QUEUE_ITEMS_PER_LISTENER\n        ) {\n          listenerQueue[lqIndex](\n            listenerQueue[lqIndex + 1],\n            listenerQueue[lqIndex + 2],\n            listenerQueue[lqIndex + 3]\n          )\n        }\n        listenerQueue.length = 0\n      }\n    },\n    /* It will be called on last listener unsubscribing.\n       We will redefine it in onMount and onStop. */\n    off() {},\n    set(newValue) {\n      let oldValue = $atom.value\n      if (oldValue !== newValue) {\n        $atom.value = newValue\n        $atom.notify(oldValue)\n      }\n    },\n    subscribe(listener) {\n      let unbind = $atom.listen(listener)\n      listener($atom.value)\n      return unbind\n    },\n    value: initialValue\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    $atom[clean] = () => {\n      listeners = []\n      $atom.lc = 0\n      $atom.off()\n    }\n  }\n\n  return $atom\n}\n\nexport const readonlyType = store => store\n",
    "export function listenKeys($store, keys, listener) {\n  let keysSet = new Set(keys).add(undefined)\n  return $store.listen((value, oldValue, changed) => {\n    if (keysSet.has(changed)) {\n      listener(value, oldValue, changed)\n    }\n  })\n}\n\nexport function subscribeKeys($store, keys, listener) {\n  let unbind = listenKeys($store, keys, listener)\n  listener($store.value)\n  return unbind\n}\n",
    "import type { BetterAuthClientPlugin } from \"better-auth/client\";\nimport type { BetterFetchOption } from \"@better-fetch/fetch\";\nimport { atom } from \"nanostores\";\nimport type { paymongo } from \"./server\";\nimport type { SubscriptionData } from \"./types\";\n\n// Atoms for reactive subscription state\nexport const subscriptionAtom = atom<SubscriptionData | null>(null);\nexport const subscriptionLoadingAtom = atom<boolean>(false);\nexport const subscriptionErrorAtom = atom<Error | null>(null);\n\nexport const paymongoClient = () => {\n    return {\n        id: \"paymongo\",\n        $InferServerPlugin: {} as ReturnType<typeof paymongo>,\n\n        getAtoms: () => {\n            return {\n                $subscription: subscriptionAtom,\n                $subscriptionLoading: subscriptionLoadingAtom,\n                $subscriptionError: subscriptionErrorAtom\n            };\n        },\n\n        getActions: ($fetch: <T>(url: string, options?: BetterFetchOption) => Promise<{ data: T | null; error: { message: string } | null }>) => ({\n            /**\n             * Fetch subscription and update atoms\n             */\n            fetchSubscription: async (options?: { organizationId?: string }) => {\n                subscriptionLoadingAtom.set(true);\n                subscriptionErrorAtom.set(null);\n\n                try {\n                    const query = options?.organizationId ? `?organizationId=${options.organizationId}` : \"\";\n                    const result = await $fetch<SubscriptionData | null>(`/paymongo/get-subscription${query}`, {\n                        method: \"GET\"\n                    });\n\n                    if (result.error) {\n                        subscriptionErrorAtom.set(new Error(result.error.message));\n                        return { data: null, error: result.error };\n                    } else {\n                        subscriptionAtom.set(result.data);\n                        return { data: result.data, error: null };\n                    }\n                } catch (e) {\n                    const error = e instanceof Error ? e : new Error(\"Failed to fetch subscription\");\n                    subscriptionErrorAtom.set(error);\n                    return { data: null, error: { message: error.message } };\n                } finally {\n                    subscriptionLoadingAtom.set(false);\n                }\n            },\n\n            /**\n             * Get the current plan ID for the active organization or user\n             */\n            getPlan: async (options?: { organizationId?: string }, fetchOptions?: BetterFetchOption) => {\n                const query = options?.organizationId ? `?organizationId=${options.organizationId}` : \"\";\n                const res = await $fetch<SubscriptionData | null>(`/paymongo/get-subscription${query}`, {\n                    method: \"GET\",\n                    ...fetchOptions\n                });\n                return {\n                    data: res.data?.planId ?? null,\n                    error: res.error\n                };\n            },\n\n            /**\n             * Get the full subscription data for the active organization or user\n             */\n            getSubscription: async (options?: { organizationId?: string }, fetchOptions?: BetterFetchOption) => {\n                const query = options?.organizationId ? `?organizationId=${options.organizationId}` : \"\";\n                return $fetch<SubscriptionData | null>(`/paymongo/get-subscription${query}`, {\n                    method: \"GET\",\n                    ...fetchOptions\n                });\n            },\n\n            /**\n             * Check if the organization or user has an active subscription\n             */\n            hasActiveSubscription: async (options?: { organizationId?: string }, fetchOptions?: BetterFetchOption) => {\n                const query = options?.organizationId ? `?organizationId=${options.organizationId}` : \"\";\n                const res = await $fetch<SubscriptionData | null>(`/paymongo/get-subscription${query}`, {\n                    method: \"GET\",\n                    ...fetchOptions\n                });\n                const isActive = res.data?.status === \"active\" || res.data?.status === \"trialing\";\n                return {\n                    data: isActive,\n                    error: res.error\n                };\n            }\n        })\n    } satisfies BetterAuthClientPlugin;\n};\n",
    "import { listenKeys } from 'nanostores'\nimport { useCallback, useRef, useSyncExternalStore } from 'react'\n\nlet emit = (snapshotRef, onChange) => value => {\n  if (snapshotRef.current === value) return\n  snapshotRef.current = value\n  onChange()\n}\n\nexport function useStore(store, { keys, deps = [store, keys] } = {}) {\n  let snapshotRef = useRef()\n  snapshotRef.current = store.get()\n\n  let subscribe = useCallback(onChange => {\n    emit(snapshotRef, onChange)(store.value)\n\n    return keys?.length > 0\n      ? listenKeys(store, keys, emit(snapshotRef, onChange))\n      : store.listen(emit(snapshotRef, onChange))\n  }, deps)\n  let get = () => snapshotRef.current\n\n  return useSyncExternalStore(subscribe, get, get)\n}\n",
    "import { useStore } from \"@nanostores/react\";\nimport { subscriptionAtom, subscriptionLoadingAtom, subscriptionErrorAtom } from \"./client\";\nimport type { SubscriptionData } from \"./types\";\n\n/**\n * Hook to get the current subscription data\n * Uses nanostores for reactive updates\n * \n * @example\n * ```tsx\n * import { useSubscription } from \"better-auth-paymongo/react\";\n * \n * function MyComponent() {\n *   const { subscription, isLoading } = useSubscription();\n *   if (isLoading) return <Spinner />;\n *   return <div>Plan: {subscription?.planId}</div>;\n * }\n * ```\n */\nexport function useSubscription() {\n  const subscription = useStore(subscriptionAtom);\n  const isLoading = useStore(subscriptionLoadingAtom);\n  const error = useStore(subscriptionErrorAtom);\n\n  const isActive = subscription?.status === \"active\";\n  const isTrialing = subscription?.status === \"trialing\";\n\n  return {\n    subscription,\n    planId: subscription?.planId ?? null,\n    status: subscription?.status ?? null,\n    isActive,\n    isTrialing,\n    isSubscribed: isActive || isTrialing,\n    isLoading,\n    error\n  };\n}\n\n/**\n * Hook to get just the plan ID\n */\nexport function usePlan() {\n  const { planId, isActive, isTrialing, isLoading, error } = useSubscription();\n  return { planId, isActive, isTrialing, isLoading, error };\n}\n\n/**\n * Hook to check if user/org has active subscription\n */\nexport function useIsSubscribed() {\n  const { isSubscribed, isActive, isTrialing, isLoading, error } = useSubscription();\n  return { isSubscribed, isActive, isTrialing, isLoading, error };\n}\n\n/**\n * Hook to get usage for a specific limit\n */\nexport function useUsage(limitKey: string) {\n  const { subscription, isLoading, error } = useSubscription();\n  const usage = subscription?.usage?.[limitKey] ?? 0;\n\n  return {\n    usage,\n    planId: subscription?.planId ?? null,\n    isLoading,\n    error\n  };\n}\n\n// Re-export atoms for advanced usage\nexport { subscriptionAtom, subscriptionLoadingAtom, subscriptionErrorAtom } from \"./client\";\n",
    "import type { BetterAuthPlugin } from \"better-auth\";\nimport { createAuthEndpoint, sessionMiddleware } from \"better-auth/api\";\nimport { z } from \"zod\";\nimport type { PaymongoPluginConfig, SubscriptionData, BasePlanConfig, BaseAddonConfig } from \"./types\";\n\n// Type extension for adapter methods that exist at runtime but not in type definitions\ninterface ExtendedAdapter {\n    findUser(id: string): Promise<{ id: string; paymongoData?: string | null } | null>;\n    updateUser(id: string, data: { paymongoData: string }): Promise<void>;\n    findOrganization(id: string): Promise<{ id: string; paymongoData?: string | null } | null>;\n    updateOrganization(id: string, data: { paymongoData: string }): Promise<void>;\n}\n\n// Helper to get typed adapter\nconst getAdapter = (ctx: { context: { adapter: unknown } }): ExtendedAdapter =>\n    ctx.context.adapter as ExtendedAdapter;\n\n// Helper for PayMongo API calls\nexport const paymongoFetch = async (endpoint: string, method: string, secretKey: string, body?: unknown): Promise<{ data: { id: string; attributes: Record<string, unknown> } }> => {\n    const url = `https://api.paymongo.com/v1${endpoint}`;\n    const headers = {\n        accept: 'application/json',\n        'content-type': 'application/json',\n        authorization: `Basic ${btoa(secretKey + ':')}`\n    };\n\n    const response = await fetch(url, {\n        method,\n        headers,\n        body: body ? JSON.stringify(body) : undefined\n    });\n\n    if (!response.ok) {\n        const error = await response.json().catch(() => ({})) as { errors?: Array<{ detail?: string }> };\n        throw new Error(error.errors?.[0]?.detail || `PayMongo API Error: ${response.statusText}`);\n    }\n\n    return response.json() as Promise<{ data: { id: string; attributes: Record<string, unknown> } }>;\n};\n\nconst getPaymongoData = (record: any): SubscriptionData | null => {\n    if (!record.paymongoData) return null;\n    try {\n        return JSON.parse(record.paymongoData);\n    } catch {\n        return null;\n    }\n};\n\nexport const paymongo = <\n    TPlans extends Record<string, BasePlanConfig>,\n    TAddons extends Record<string, BaseAddonConfig>\n>(\n    config: PaymongoPluginConfig<TPlans, TAddons>\n) => {\n    return {\n        id: \"paymongo\",\n        schema: {\n            user: {\n                fields: {\n                    paymongoData: {\n                        type: \"string\",\n                        required: false,\n                        returned: false,\n                    },\n                },\n            },\n            organization: {\n                fields: {\n                    paymongoData: {\n                        type: \"string\",\n                        required: false,\n                        returned: false,\n                    },\n                },\n            },\n        },\n        endpoints: {\n            createPaymentIntent: createAuthEndpoint(\"/paymongo/create-payment-intent\", {\n                method: \"POST\",\n                body: z.object({\n                    planId: z.string(),\n                    organizationId: z.string().optional(),\n                }),\n                use: [sessionMiddleware],\n            }, async (ctx) => {\n                const { planId, organizationId } = ctx.body;\n                const plan = config.plans[planId];\n                if (!plan) {\n                    throw new Error(\"Invalid plan ID\");\n                }\n\n                let amount: number;\n                let currency: string;\n\n                try {\n                    const priceData = await paymongoFetch(`/prices/${plan.priceId}`, \"GET\", config.secretKey);\n                    amount = priceData.data.attributes.unit_amount as number;\n                    currency = priceData.data.attributes.currency as string;\n                } catch (e) {\n                    throw new Error(`Failed to fetch price details: ${e instanceof Error ? e.message : \"Unknown error\"}`);\n                }\n\n                const paymentIntent = await paymongoFetch(\"/payment_intents\", \"POST\", config.secretKey, {\n                    data: {\n                        attributes: {\n                            amount,\n                            currency,\n                            description: `Subscription to ${plan.displayName}`,\n                            payment_method_allowed: [\"card\", \"gcash\", \"paymaya\"],\n                            metadata: {\n                                planId,\n                                userId: ctx.context.session.user.id,\n                                organizationId,\n                            }\n                        }\n                    }\n                });\n\n                return {\n                    clientKey: paymentIntent.data.attributes.client_key,\n                    paymentIntentId: paymentIntent.data.id\n                };\n            }),\n\n            createSubscription: createAuthEndpoint(\"/paymongo/create-subscription\", {\n                method: \"POST\",\n                body: z.object({\n                    planId: z.string(),\n                    paymentIntentId: z.string().optional(),\n                    organizationId: z.string().optional(),\n                }),\n                use: [sessionMiddleware],\n            }, async (ctx) => {\n                const { planId, paymentIntentId, organizationId } = ctx.body;\n                const plan = config.plans[planId];\n                if (!plan) throw new Error(\"Invalid plan ID\");\n\n                let status: SubscriptionData['status'] = 'pending';\n                let currentPeriodEnd = new Date();\n                let trialEndsAt: Date | undefined;\n\n                // Handle Trial\n                if (plan.trialPeriodDays && plan.trialPeriodDays > 0 && !paymentIntentId) {\n                    status = 'trialing';\n                    trialEndsAt = new Date();\n                    trialEndsAt.setDate(trialEndsAt.getDate() + plan.trialPeriodDays);\n                    currentPeriodEnd = trialEndsAt;\n                }\n                // Handle Payment\n                else if (paymentIntentId) {\n                    const pi = await paymongoFetch(`/payment_intents/${paymentIntentId}`, \"GET\", config.secretKey);\n                    const piStatus = pi.data.attributes.status;\n                    if (piStatus === 'succeeded' || piStatus === 'processing') {\n                        status = piStatus === 'succeeded' ? 'active' : 'pending';\n                        const daysToAdd = plan.interval === 'year' ? 365 : 30;\n                        currentPeriodEnd.setDate(currentPeriodEnd.getDate() + daysToAdd);\n                    } else {\n                        throw new Error(`PaymentIntent status is ${piStatus}`);\n                    }\n                } else {\n                    throw new Error(\"PaymentIntent required for non-trial plans\");\n                }\n\n                const subData: SubscriptionData = {\n                    id: `sub_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n                    status,\n                    planId,\n                    currentPeriodEnd,\n                    cancelAtPeriodEnd: false,\n                    addons: {},\n                    usage: {},\n                    trialEndsAt,\n                    paymentIntentId\n                };\n\n                if (plan.limits) {\n                    for (const key of Object.keys(plan.limits)) {\n                        subData.usage[key] = 0;\n                    }\n                }\n\n                const updateData = { paymongoData: JSON.stringify(subData) };\n\n                const adapter = getAdapter(ctx);\n                if (organizationId) {\n                    await adapter.updateOrganization(organizationId, updateData);\n                } else {\n                    await adapter.updateUser(ctx.context.session.user.id, updateData);\n                }\n\n                if (config.onSubscriptionCreate) {\n                    await config.onSubscriptionCreate({\n                        userId: ctx.context.session.user.id,\n                        orgId: organizationId,\n                        subscriptionId: subData.id,\n                        planId\n                    });\n                }\n\n                return subData;\n            }),\n\n            verifySubscription: createAuthEndpoint(\"/paymongo/verify-subscription\", {\n                method: \"GET\",\n                query: z.object({\n                    organizationId: z.string().optional()\n                }).optional(),\n                use: [sessionMiddleware],\n            }, async (ctx) => {\n                const organizationId = ctx.query?.organizationId;\n                const adapter = getAdapter(ctx);\n                let record;\n                if (organizationId) {\n                    record = await adapter.findOrganization(organizationId);\n                } else {\n                    record = await adapter.findUser(ctx.context.session.user.id);\n                }\n\n                if (!record) throw new Error(\"Record not found\");\n\n                const subData = getPaymongoData(record);\n                if (!subData) return null;\n\n                if ((subData.status === 'pending' || subData.status === 'unpaid') && subData.paymentIntentId) {\n                    try {\n                        const pi = await paymongoFetch(`/payment_intents/${subData.paymentIntentId}`, \"GET\", config.secretKey);\n                        const piStatus = pi.data.attributes.status;\n\n                        let newStatus: SubscriptionData['status'] = subData.status;\n\n                        if (piStatus === 'succeeded') {\n                            newStatus = 'active';\n                        } else if (piStatus === 'cancelled') {\n                            newStatus = 'canceled';\n                        }\n\n                        if (newStatus !== subData.status) {\n                            subData.status = newStatus;\n                            const updateData = { paymongoData: JSON.stringify(subData) };\n                            if (organizationId) {\n                                await adapter.updateOrganization(organizationId, updateData);\n                            } else {\n                                await adapter.updateUser(ctx.context.session.user.id, updateData);\n                            }\n\n                            if (config.onSubscriptionVerify) {\n                                await config.onSubscriptionVerify({\n                                    userId: ctx.context.session.user.id,\n                                    orgId: organizationId,\n                                    subscriptionId: subData.id,\n                                    status: newStatus\n                                });\n                            }\n                        }\n                    } catch (e) {\n                        // Ignore error\n                    }\n                }\n\n                return subData;\n            }),\n\n            cancelSubscription: createAuthEndpoint(\"/paymongo/cancel-subscription\", {\n                method: \"POST\",\n                body: z.object({\n                    organizationId: z.string().optional()\n                }),\n                use: [sessionMiddleware],\n            }, async (ctx) => {\n                const { organizationId } = ctx.body;\n                const userId = ctx.context.session.user.id;\n                const adapter = getAdapter(ctx);\n\n                const record = organizationId\n                    ? await adapter.findOrganization(organizationId)\n                    : await adapter.findUser(userId);\n\n                if (!record) throw new Error(\"Record not found\");\n\n                const subData = getPaymongoData(record);\n                if (!subData) throw new Error(\"No subscription found\");\n\n                if (subData.status === 'canceled') return subData;\n\n                subData.cancelAtPeriodEnd = true;\n\n                const updateData = { paymongoData: JSON.stringify(subData) };\n                if (organizationId) {\n                    await adapter.updateOrganization(organizationId, updateData);\n                } else {\n                    await adapter.updateUser(userId, updateData);\n                }\n\n                if (config.onSubscriptionCancel) {\n                    await config.onSubscriptionCancel({\n                        userId,\n                        orgId: organizationId,\n                        subscriptionId: subData.id\n                    });\n                }\n\n                return subData;\n            }),\n\n            switchPlan: createAuthEndpoint(\"/paymongo/switch-plan\", {\n                method: \"POST\",\n                body: z.object({\n                    newPlanId: z.string(),\n                    organizationId: z.string().optional()\n                }),\n                use: [sessionMiddleware],\n            }, async (ctx) => {\n                const { newPlanId, organizationId } = ctx.body;\n                const userId = ctx.context.session.user.id;\n                const adapter = getAdapter(ctx);\n\n                const newPlan = config.plans[newPlanId];\n                if (!newPlan) throw new Error(\"Invalid plan ID\");\n\n                const record = organizationId\n                    ? await adapter.findOrganization(organizationId)\n                    : await adapter.findUser(userId);\n\n                if (!record) throw new Error(\"Record not found\");\n                const subData = getPaymongoData(record);\n                if (!subData) throw new Error(\"No subscription found\");\n\n                const oldPlanId = subData.planId;\n                if (oldPlanId === newPlanId) return subData;\n\n                subData.planId = newPlanId;\n                if (newPlan.limits) {\n                    for (const key of Object.keys(newPlan.limits)) {\n                        if (subData.usage[key] === undefined) {\n                            subData.usage[key] = 0;\n                        }\n                    }\n                }\n\n                const updateData = { paymongoData: JSON.stringify(subData) };\n                if (organizationId) {\n                    await adapter.updateOrganization(organizationId, updateData);\n                } else {\n                    await adapter.updateUser(userId, updateData);\n                }\n\n                if (config.onPlanSwitch) {\n                    await config.onPlanSwitch({\n                        userId,\n                        orgId: organizationId,\n                        oldPlanId,\n                        newPlanId\n                    });\n                }\n\n                return subData;\n            }),\n\n            addAddon: createAuthEndpoint(\"/paymongo/add-addon\", {\n                method: \"POST\",\n                body: z.object({\n                    addonId: z.string(),\n                    quantity: z.number().min(1).default(1),\n                    organizationId: z.string().optional()\n                }),\n                use: [sessionMiddleware],\n            }, async (ctx) => {\n                const { addonId, quantity, organizationId } = ctx.body;\n                const addon = config.addons?.[addonId];\n                if (!addon) throw new Error(\"Invalid addon ID\");\n                const adapter = getAdapter(ctx);\n\n                const record = organizationId\n                    ? await adapter.findOrganization(organizationId)\n                    : await adapter.findUser(ctx.context.session.user.id);\n\n                if (!record) throw new Error(\"Record not found\");\n                const subData = getPaymongoData(record);\n                if (!subData) throw new Error(\"No subscription found\");\n\n                if (!subData.addons[addonId]) {\n                    subData.addons[addonId] = 0;\n                }\n                subData.addons[addonId] += quantity;\n\n                const updateData = { paymongoData: JSON.stringify(subData) };\n                if (organizationId) {\n                    await adapter.updateOrganization(organizationId, updateData);\n                } else {\n                    await adapter.updateUser(ctx.context.session.user.id, updateData);\n                }\n                return subData;\n            }),\n\n            checkUsage: createAuthEndpoint(\"/paymongo/check-usage\", {\n                method: \"GET\",\n                query: z.object({\n                    limitKey: z.string(),\n                    organizationId: z.string().optional()\n                }),\n                use: [sessionMiddleware],\n            }, async (ctx) => {\n                const { limitKey, organizationId } = ctx.query;\n                const adapter = getAdapter(ctx);\n                const record = organizationId\n                    ? await adapter.findOrganization(organizationId)\n                    : await adapter.findUser(ctx.context.session.user.id);\n\n                if (!record) throw new Error(\"Record not found\");\n                const subData = getPaymongoData(record);\n                if (!subData) throw new Error(\"No subscription found\");\n\n                const plan = config.plans[subData.planId];\n                if (!plan) throw new Error(\"Plan not found\");\n                const baseLimit = plan.limits[limitKey] || 0;\n\n                let bonus = 0;\n                if (config.addons) {\n                    for (const [addonId, qty] of Object.entries(subData.addons)) {\n                        const addon = config.addons[addonId];\n                        if (addon?.limitBonuses?.[limitKey]) {\n                            bonus += addon.limitBonuses[limitKey] * qty;\n                        }\n                    }\n                }\n\n                const totalLimit = baseLimit + bonus;\n                const usage = subData.usage[limitKey] || 0;\n                const remaining = Math.max(0, totalLimit - usage);\n\n                return {\n                    usage,\n                    limit: totalLimit,\n                    remaining,\n                    allowed: usage < totalLimit\n                };\n            }),\n\n            incrementUsage: createAuthEndpoint(\"/paymongo/increment-usage\", {\n                method: \"POST\",\n                body: z.object({\n                    limitKey: z.string(),\n                    quantity: z.number().default(1),\n                    organizationId: z.string().optional()\n                }),\n                use: [sessionMiddleware],\n            }, async (ctx) => {\n                const { limitKey, quantity, organizationId } = ctx.body;\n                const adapter = getAdapter(ctx);\n                const record = organizationId\n                    ? await adapter.findOrganization(organizationId)\n                    : await adapter.findUser(ctx.context.session.user.id);\n\n                if (!record) throw new Error(\"Record not found\");\n                const subData = getPaymongoData(record);\n                if (!subData) throw new Error(\"No subscription found\");\n\n                const plan = config.plans[subData.planId];\n                if (!plan) throw new Error(\"Plan not found\");\n                const baseLimit = plan.limits[limitKey] || 0;\n                let bonus = 0;\n                if (config.addons) {\n                    for (const [addonId, qty] of Object.entries(subData.addons)) {\n                        const addon = config.addons[addonId];\n                        if (addon?.limitBonuses?.[limitKey]) {\n                            bonus += addon.limitBonuses[limitKey] * qty;\n                        }\n                    }\n                }\n                const totalLimit = baseLimit + bonus;\n                const currentUsage = subData.usage[limitKey] || 0;\n                const newUsage = Math.max(0, currentUsage + quantity);\n\n                if (quantity > 0 && newUsage > totalLimit) {\n                    throw new Error(\"Usage limit exceeded\");\n                }\n\n                subData.usage[limitKey] = newUsage;\n\n                const updateData = { paymongoData: JSON.stringify(subData) };\n                if (organizationId) {\n                    await adapter.updateOrganization(organizationId, updateData);\n                } else {\n                    await adapter.updateUser(ctx.context.session.user.id, updateData);\n                }\n\n                return {\n                    success: true,\n                    usage: subData.usage[limitKey],\n                    limit: totalLimit\n                };\n            }),\n\n            getActiveSubscription: createAuthEndpoint(\"/paymongo/get-subscription\", {\n                method: \"GET\",\n                query: z.object({\n                    organizationId: z.string().optional()\n                }).optional(),\n                use: [sessionMiddleware],\n            }, async (ctx) => {\n                const organizationId = ctx.query?.organizationId;\n                const adapter = getAdapter(ctx);\n                const record = organizationId\n                    ? await adapter.findOrganization(organizationId)\n                    : await adapter.findUser(ctx.context.session.user.id);\n\n                if (!record) return null;\n                return getPaymongoData(record);\n            })\n        }\n    } satisfies BetterAuthPlugin;\n};"
  ],
  "mappings": "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",
  "debugId": "B0FE70AA4D79225B64756E2164756E21",
  "names": []
}